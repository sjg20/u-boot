# SPDX-License-Identifier: GPL-2.0+
# Copyright 2021 Google LLC
# Written by Simon Glass <sjg@chromium.org>

"""Support for ARM's Firmware Image Package (FIP) format

FIP is a format similar to FMAP[1] but with fewer features and an obscure UUID
instead of the region name.

It consists of a header and a table of entries, each pointing to a place in the
firmware image where something can be found.

[1] https://chromium.googlesource.com/chromiumos/third_party/flashmap/+/refs/heads/master/lib/fmap.h
"""

import io
import struct

from patman import tools

# The TOC header, at the start of the FIP
HEADER_FORMAT   = '<IIQ'
HEADER_LEN      = 0x10
HEADER_MAGIC    = 0xaA640001
HEADER_SERIAL   = 0x12345678

# The entry header (a table of these comes after the TOC header)
UUID_LEN        = 16
ENTRY_FORMAT    = '<%dsQQQ' % UUID_LEN
ENTRY_SIZE      = 0x28

HEADER_NAMES = (
    'name',
    'serial',
    'flags',
)

ENTRY_NAMES = (
    'uuid',
    'offset_addr',
    'size',
    'flags',
)

class FipType:
    def __init__(self, name, desc, uuid_bytes):
        self.name = name
        self.desc = desc
        self.uuid = bytes(uuid_bytes)

# This is taken from tbbr_config.c in ARM Trusted Firmware
fip_type_list = [
    # ToC Entry UUIDs
    FipType('scp-fwu-cfg', 'SCP Firmware Updater Configuration FWU SCP_BL2U',
            [0x65, 0x92, 0x27, 0x03, 0x2f, 0x74, 0xe6, 0x44,
             0x8d, 0xff, 0x57, 0x9a, 0xc1, 0xff, 0x06, 0x10]),
    FipType('soc-fw', 'EL3 Runtime Firmware BL31',
            [0x47,  0xd4, 0x08, 0x6d, 0x4c, 0xfe, 0x98, 0x46,
             0x9b, 0x95, 0x29, 0x50, 0xcb, 0xbd, 0x5a, 0x00]),

    ]


fip_types = {ftype.name: ftype for ftype in fip_type_list}

'''
#define UUID_TRUSTED_UPDATE_FIRMWARE_BL2U \
	0x60, 0xb3, 0xeb, 0x37, 0xc1, 0xe5, 0xea, 0x41, 0x9d, 0xf3, 0x19, 0xed, 0xa1, 0x1f, 0x68, 0x01
#define UUID_TRUSTED_UPDATE_FIRMWARE_NS_BL2U \
	0x4f, 0x51, 0x1d, 0x11, 0x2b, 0xe5, 0x4e, 0x49, 0xb4, 0xc5, 0x83, 0xc2, 0xf7, 0x15, 0x84, 0x0a
#define UUID_TRUSTED_FWU_CERT \
	0x71, 0x40, 0x8a, 0xb2, 0x18, 0xd6, 0x87, 0x4c, 0x8b, 0x2e, 0xc6, 0xdc, 0xcd, 0x50, 0xf0, 0x96
#define UUID_TRUSTED_BOOT_FIRMWARE_BL2 \
	0x5f, 0xf9, 0xec, 0x0b, 0x4d, 0x22, 0x3e, 0x4d, 0xa5, 0x44, 0xc3, 0x9d, 0x81, 0xc7, 0x3f, 0x0a
#define UUID_SCP_FIRMWARE_SCP_BL2 \
	0x97,  0x66, 0xfd, 0x3d, 0x89, 0xbe, 0xe8, 0x49, 0xae, 0x5d, 0x78, 0xa1, 0x40, 0x60, 0x82, 0x13

#define UUID_EL3_RUNTIME_FIRMWARE_BL31 \

#define UUID_SECURE_PAYLOAD_BL32 \
	0x05,  0xd0, 0xe1, 0x89, 0x53, 0xdc, 0x13, 0x47, 0x8d, 0x2b, 0x50, 0x0a, 0x4b, 0x7a, 0x3e, 0x38
#define UUID_SECURE_PAYLOAD_BL32_EXTRA1 \
	0x0b,  0x70, 0xc2, 0x9b, 0x2a, 0x5a, 0x78, 0x40, 0x9f, 0x65, 0x0a, 0x56, 0x82, 0x73, 0x82, 0x88
#define UUID_SECURE_PAYLOAD_BL32_EXTRA2 \
	0x8e,  0xa8, 0x7b, 0xb1, 0xcf, 0xa2, 0x3f, 0x4d, 0x85, 0xfd, 0xe7, 0xbb, 0xa5, 0x02, 0x20, 0xd9
#define UUID_NON_TRUSTED_FIRMWARE_BL33 \
	0xd6,  0xd0, 0xee, 0xa7, 0xfc, 0xea, 0xd5, 0x4b, 0x97, 0x82, 0x99, 0x34, 0xf2, 0x34, 0xb6, 0xe4
#define UUID_REALM_MONITOR_MGMT_FIRMWARE \
	0x6c,  0x07, 0x62, 0xa6, 0x12, 0xf2, 0x4b, 0x56, 0x92, 0xcb, 0xba, 0x8f, 0x63, 0x36, 0x06, 0xd9
/* Key certificates */
#define UUID_ROT_KEY_CERT \
	0x86,  0x2d, 0x1d, 0x72, 0xf8, 0x60, 0xe4, 0x11, 0x92, 0x0b, 0x8b, 0xe7, 0x62, 0x16, 0x0f, 0x24
#define UUID_TRUSTED_KEY_CERT \
	0x82,  0x7e, 0xe8, 0x90, 0xf8, 0x60, 0xe4, 0x11, 0xa1, 0xb4, 0x77, 0x7a, 0x21, 0xb4, 0xf9, 0x4c
#define UUID_NON_TRUSTED_WORLD_KEY_CERT \
	0x1c,  0x67, 0x87, 0x3d, 0x5f, 0x63, 0xe4, 0x11, 0x97, 0x8d, 0x27, 0xc0, 0xc7, 0x14, 0x8a, 0xbd
#define UUID_SCP_FW_KEY_CERT \
	0x02,  0x42, 0x21, 0xa1, 0xf8, 0x60, 0xe4, 0x11, 0x8d, 0x9b, 0xf3, 0x3c, 0x0e, 0x15, 0xa0, 0x14
#define UUID_SOC_FW_KEY_CERT \
	0x8a,  0xb8, 0xbe, 0xcc, 0xf9, 0x60, 0xe4, 0x11, 0x9a, 0xd0, 0xeb, 0x48, 0x22, 0xd8, 0xdc, 0xf8
#define UUID_TRUSTED_OS_FW_KEY_CERT \
	0x94,  0x77, 0xd6, 0x03, 0xfb, 0x60, 0xe4, 0x11, 0x85, 0xdd, 0xb7, 0x10, 0x5b, 0x8c, 0xee, 0x04
#define UUID_NON_TRUSTED_FW_KEY_CERT \
	0x8a,  0xd5, 0x83, 0x2a, 0xfb, 0x60, 0xe4, 0x11, 0x8a, 0xaf, 0xdf, 0x30, 0xbb, 0xc4, 0x98, 0x59
/* Content certificates */
#define UUID_TRUSTED_BOOT_FW_CERT \
	0xd6,  0xe2, 0x69, 0xea, 0x5d, 0x63, 0xe4, 0x11, 0x8d, 0x8c, 0x9f, 0xba, 0xbe, 0x99, 0x56, 0xa5
#define UUID_SCP_FW_CONTENT_CERT \
	0x44,  0xbe, 0x6f, 0x04, 0x5e, 0x63, 0xe4, 0x11, 0xb2, 0x8b, 0x73, 0xd8, 0xea, 0xae, 0x96, 0x56
#define UUID_SOC_FW_CONTENT_CERT \
	0xe2,  0xb2, 0x0c, 0x20, 0x5e, 0x63, 0xe4, 0x11, 0x9c, 0xe8, 0xab, 0xcc, 0xf9, 0x2b, 0xb6, 0x66
#define UUID_TRUSTED_OS_FW_CONTENT_CERT \
	0xa4,  0x9f, 0x44, 0x11, 0x5e, 0x63, 0xe4, 0x11, 0x87, 0x28, 0x3f, 0x05, 0x72, 0x2a, 0xf3, 0x3d
#define UUID_NON_TRUSTED_FW_CONTENT_CERT \
	0x8e,  0xc4, 0xc1, 0xf3, 0x5d, 0x63, 0xe4, 0x11, 0xa7, 0xa9, 0x87, 0xee, 0x40, 0xb2, 0x3f, 0xa7
#define UUID_SIP_SECURE_PARTITION_CONTENT_CERT \
	0x77,  0x6d, 0xfd, 0x44, 0x86, 0x97, 0x4c, 0x3b, 0x91, 0xeb, 0xc1, 0x3e, 0x02, 0x5a, 0x2a, 0x6f
#define UUID_PLAT_SECURE_PARTITION_CONTENT_CERT \
	0xdd,  0xcb, 0xbf, 0x4a, 0xca, 0xd6, 0x11, 0xea, 0x87, 0xd0, 0x02, 0x42, 0xac, 0x13, 0x00, 0x03
/* Dynamic configs */
#define UUID_HW_CONFIG \
	0x08,  0xb8, 0xf1, 0xd9, 0xc9, 0xcf, 0x93, 0x49, 0xa9, 0x62, 0x6f, 0xbc, 0x6b, 0x72, 0x65, 0xcc
#define UUID_TB_FW_CONFIG \
	0x6c,  0x04, 0x58, 0xff, 0xaf, 0x6b, 0x7d, 0x4f, 0x82, 0xed, 0xaa, 0x27, 0xbc, 0x69, 0xbf, 0xd2
#define UUID_SOC_FW_CONFIG \
	0x99,  0x79, 0x81, 0x4b, 0x03, 0x76, 0xfb, 0x46, 0x8c, 0x8e, 0x8d, 0x26, 0x7f, 0x78, 0x59, 0xe0
#define UUID_TOS_FW_CONFIG \
	0x26,  0x25, 0x7c, 0x1a, 0xdb, 0xc6, 0x7f, 0x47, 0x8d, 0x96, 0xc4, 0xc4, 0xb0, 0x24, 0x80, 0x21
#define UUID_NT_FW_CONFIG \
	0x28,  0xda, 0x98, 0x15, 0x93, 0xe8, 0x7e, 0x44, 0xac, 0x66, 0x1a, 0xaf, 0x80, 0x15, 0x50, 0xf9
#define UUID_FW_CONFIG \
	0x58,  0x07, 0xe1, 0x6a, 0x84, 0x59, 0x47, 0xbe, 0x8e, 0xd5, 0x64, 0x8e, 0x8d, 0xdd, 0xab, 0x0e
'''

def align_int(val, align):
    """Align a value up to the given alignment

    Args:
        val: Integer value to align
        align: Integer alignment value (e.g. 4 to align to 4-byte boundary)

    Returns:
        integer value aligned to the required boundary, rounding up if necessary
    """
    return int((val + align - 1) / align) * align

class FipHeader:
    def __init__(self, name, serial, flags):
        self.name = name
        self.serial = serial
        self.flags = flags


class FipEntry:
    """Class to represent a single FIP entry

    This is used to hold the information about an entry, including its contents.
    Use the get_data() method to obtain the raw output for writing to the FIP
    file.
    """
    def __init__(self, uuid, offset, size, flags):
        self.uuid = uuid
        self.offset = offset
        self.size = size
        self.flags = flags
        self.fip_type = None
        self.data = None
        self.valid = uuid != tools.GetBytes(0, UUID_LEN)
        if self.valid:
            # Look up the friendly name
            matches = {val for (key, val) in fip_types.items()
                       if val.uuid == uuid}
            if len(matches) == 1:
                self.fip_type = matches.pop().name

    @classmethod
    def from_type(cls, fip_type, data, flags):
        fent = FipEntry(fip_types[fip_type].uuid, None, len(data), flags)
        fent.fip_type = fip_type
        fent.data = data
        return fent


def decode_fip(data):
    """Decode a FIP into a header and list of FIP entries

    Args:
        data: Data block containing the FMAP

    Returns:
        Tuple:
            header: FipHeader object
            List of FipArea objects
    """
    fields = list(struct.unpack(HEADER_FORMAT, data[:HEADER_LEN]))
    header = FipHeader(*fields)
    fents = []
    pos = HEADER_LEN
    while True:
        fields = list(struct.unpack(ENTRY_FORMAT, data[pos:pos + ENTRY_SIZE]))
        fent = FipEntry(*fields)
        if not fent.valid:
            break
        fent.data = data[fent.offset:fent.offset + fent.size]
        fents.append(fent)
        pos += ENTRY_SIZE
    return header, fents


class FipWriter:
    """Class to handle writing a ARM Trusted Firmware Firmware Image Package

    Usage is something like:

        fip = FipWriter(size)
        fip.add_file('scp-fwu-cfg', tools.ReadFile('something.bin'))
        ...
        data = cbw.get_data()

    Attributes:
    """
    def __init__(self, flags, align):
        self._fip_entries = []
        self._flags = flags
        self._align = align

    def add_file(self, fip_type, data, flags):
        fent = FipEntry.from_type(fip_type, data, flags)
        self._fip_entries.append(fent)

    def _align_to(self, fd, align):
        """Write out pad bytes until a given alignment is reached

        This only aligns if the resulting output would not reach the end of the
        CBFS, since we want to leave the last 4 bytes for the master-header
        pointer.

        Args:
            fd: File objext to write to
            align: Alignment to require (e.g. 4 means pad to next 4-byte
                boundary)
        """
        offset = align_int(fd.tell(), align)
        if offset < self._size:
            self._skip_to(fd, offset)

    def get_data(self):
        """Obtain the full contents of the FIP

        Thhis builds the FIP with headers and all required FIP entries.

        Returns:
            'bytes' type containing the data
        """
        fd = io.BytesIO()
        hdr = struct.pack(HEADER_FORMAT, HEADER_MAGIC, HEADER_SERIAL,
                          self._flags)
        fd.write(hdr)

        # Calculate the position fo the first entry
        offset = len(hdr)
        offset += len(self._fip_entries) * ENTRY_SIZE
        offset += ENTRY_SIZE   # terminating entry

        for fent in self._fip_entries:
            offset = tools.Align(offset, self._align)
            fent.offset = offset
            offset += fent.size

        # Write out the TOC
        for fent in self._fip_entries:
            hdr = struct.pack(ENTRY_FORMAT, fent.uuid, fent.offset, fent.size,
                              fent.flags)
            fd.write(hdr)

        # Write out the entries
        for fent in self._fip_entries:
            fd.seek(fent.offset)
            fd.write(fent.data)

        return fd.getvalue()
