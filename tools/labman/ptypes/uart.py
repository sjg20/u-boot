# SPDX-License-Identifier: GPL-2.0+
# Copyright 2020 Google LLC
# Written by Simon Glass <sjg@chromium.org>

import time

from labman.part import Part
from labman import work
from patman import tout

class Part_uart(Part):
    """A UART which can provide a console connection to a DUT
    """
    def __init__(self):
        super().__init__()
        self._need_dut_power = False

    def load(self, yam):
        """Load the object from a yaml definition

        Args:
            yam (dict): Yaml definition
        """
        self._type = yam.get('type')
        self._speed = yam.get('speed', 115200)
        if self._type is None:
            self.Raise("Invalid type '%s'" % cname)
        if self._type == 'usb-uart':
            self._symlink = yam.get('symlink')
            if self._symlink is None:
                self.raise_self("Missing symlink")
            self.load_usb_port(yam)
            self._port = '/dev/%s' % self._symlink
        elif self._type == 'portserver':
            self.num_ports = yam.get('num-ports')
            if not self.num_ports:
                self.raise_self("Missing num-ports in %s" % yam)
            self._host = yam.get('host')
            if self._host is None:
                self._host("Missing host")
            self._base_port = yam.get('base-port')
            if self._base_port is None:
                self._host("Missing base-port")
        else:
            self.raise_self("Unknown uart type '%s'" % self._type)
        self._need_dut_power = yam.get('need-dut-power')
        self._dut_power_delay = yam.get('dut-power-delay')

    def __str__(self):
        """Convert the object into a string for presentation to the user"""
        return 'uart %s' % self.name

    def raise_self(self, msg):
        """Raise an error related to this Uart

        Args:
            msg (str): Message to report

        Raises:
            ValueError: always
        """
        raise ValueError('%s: %s' % (str(self), msg))

    def get_detail(self, port=None):
        if self._type == 'usb-uart':
            return '%s' % self._symlink
        else:
            return '%s' % self._host

    def get_all_detail(self, out):
        if self._type == 'usb-uart':
            out['symlink'] = self._symlink
        else:
            out['symlink'] = self._host
        return out

    def check(self):
        if self._type != 'usb-uart':
            cmd = ("echo -e 'tbot\\ntbot\\ninfo serial\\nquit\\n' | "
                   "nc -w 2 %s telnet" % self._host)
            result = self.lab.run_command("bash", "-c", cmd, binary=True)
            good = b'login' in result.stdout
            if good:
                msg = ''
            else:
                msg = 'Cannot connect: %s' % result.stdout
            return work.CheckResult(self, good, msg)
        tries = 1
        dut = None

        try:
            # If this UART is powered by a DUT (e.g. it is integrated onto the
            # board, then turn the dut on and allow a bit of time for it to
            # appear
            if self._need_dut_power:
                dut = self.find_dut_by_uart()
                tout.Detail("%s: Need dut '%s' power" % (str(self), str(dut)))
                dut.set_power(True)
                tries = 5

            for i in range(tries):
                result = self.lab.run_command('head', '-0', self._port)
                if not result.return_code:
                    good = True
                    msg = ''
                    break
                else:
                    good = False
                    msg = result.stderr.strip()
                time.sleep(1)
            if dut:
                dut.set_power(False)
        except ValueError as exc:
            good = False
            msg = str(exc)
        return work.CheckResult(self, good, msg)

    def emit(self):
        emit_list = []
        emit_list.append(self.emit_udev())
        return emit_list

    def emit_udev(self):
        if self._type != 'usb-uart':
            return None
        vals = {
            'name': str(self),
            'kernel_phys_port': self._kernel_phys_port,
            'symlink': self._symlink,
            }
        out = '''# {name}
ACTION=="add|bind" \\
, KERNEL=="ttyUSB*" \\
, SUBSYSTEM=="tty" \\
, KERNELS=="{kernel_phys_port}" \\
, MODE="0666" \\
, SYMLINK+="{symlink}"

'''.format(**vals)
        return work.EmitResult(self, 'udev/99-labman-serial.rules', out,
                               '# Generated by labman')

    def get_py_class_vars(self, part_ref):
        if self._type == 'usb-uart':
            dev = '/dev/%s' % self._symlink
        else:
            dev = '%s:%s' % (self._host, self._base_port + int(part_ref.port))
        return {
            'console_uart': dev,
            }

    @classmethod
    def guess_part(cls, lab, phys):
        result = lab.check_usb_exists(phys + ':1.0', 'ttyUSB*/driver')
        if result:
            return result.split('/')[-2]
        return None

    def get_code(self, prop, prop_list, partref):
        if prop == 'get_uart':
            if self._dut_power_delay:
                return 'self.wait_for_uart(%s)' % self._dut_power_delay
        elif prop == 'connect_uart':
            if self._type == 'usb-uart':
                return 'mach.open_channel("picocom", "-q", "-b", "%d", self.console_uart)' % self._speed
            elif self._type == 'portserver':
                return ('mach.open_channel("bash", "-c", "stty raw; nc %s %s")' %
                    (self._host, self._base_port + int(partref.port)))
