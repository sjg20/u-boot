# SPDX-License-Identifier: GPL-2.0+
# Copyright 2020 Google LLC
# Written by Simon Glass <sjg@chromium.org>

import os
import re
import select
import shutil
import sys
import threading
import time
from typing import Optional

from labman.part import Part
from labman import work

STATE_INIT, STATE_WAIT, STATE_ERROR, STATE_READY = range(4)

UBTEST = '/vid/software/devel/ubtest'
SERVOD = os.path.join(UBTEST, 'standalone-hdctools/servod')
DUT_CONTROL = os.path.join(UBTEST, 'standalone-hdctools/dut-control')
RCFILE = os.path.join(UBTEST, 'servodrc')
LOGDIR = os.path.join(UBTEST, 'logs')

class ServoComms(object):
    """Handle initial communication with a servo board

    This supports starting a servod daemon for the board and checking the
    progress of the daemon.

    Properties:
        name: Name of board, as per the rc file (e.g. 'samus')
        port: Port number for the servo daemon (e.g. 9900)
        proc: Subprocess for the servo daemon, or None if not started
        fd: File descriptor for the daemon's 'info' file, None if not started
        ready: True if the servo daemon is ready to serve traffic
        logs: Directory used by the daemon for log files
        info_file: Filename of the daemon's 'info' file
        state: Current STATE_... of this servo
        buf: Buffer containing date read from @info_file. We read out from this
            a line at a time
        errs: List of error messages written by servod into the @info_file
    """

    def __init__(self, name, port, serial, board, logdir, lab):
        self.name = name
        self.port = port
        self._serial = serial
        self._board = board
        self.proc = None
        self.fd = None
        self.ready = False
        self._logdir = logdir
        self._lab = lab
        self.logs = os.path.join(logdir, 'servod_%s' % self.port)
        self.info_file = os.path.join(self.logs, 'latest.INFO')
        self._rcfile = os.path.join(logdir, 'servodrc_%s' % self.name)
        self.state = STATE_INIT
        self.buf = b''
        self.errs = []
        self._pts = None

    def remove_logs(self):
        """Remove any pre-existing logs for this daemon"""
        os.system('sudo rm -rf "%s"' % self.logs)

    def start(self):
        """Start the servo daemon and wait until its log file can be accessed"""
        if not os.path.exists(self.logs):
            os.mkdir(self.logs)

        with open(self._rcfile, 'w') as fd:
            print('''# Generated by labman

# This file describes servo boards connected to this host.
#
# Line text starting with # to end of line is ignored, as well as empy lines.
#
# Configuration lines consist of up to 4 comma separated fields, the last
# two are optional:
#
# name serial-number port-number board
#
%s, %s, %s, %s
''' % (self.name, self._serial, self.port, self._board), file=fd)
        cmd = ['sudo', SERVOD, '--rcfile', self._rcfile, '--name', self.name,
               '--port', str(self.port), '--log-dir', self._logdir]
        self.proc = self._lab.run_subprocess(*cmd)
        done = False
        for wait in range(30):
            if self.proc.poll():
                out = self.proc.communicate(timeout=100)
                raise ValueError("servod died: '%s'" % out[1])
            if os.path.exists(self.info_file):
                done = True
                break
            time.sleep(.1)
        if not done:
            raise ValueError("Timeout starting servod: '%s'" % ' '.join(cmd))
        self.fd = os.open(self.info_file, os.O_RDONLY)
        if not self.fd:
            raise ValueError("Cannot open file '%s'" % self.info_file)
        self.state = STATE_WAIT

    def process_data(self, data):
        """Process data received from servod, waiting for it to be ready

        Returns:
            True if servo is ready, False if not
        """
        self.buf += data
        while b'\n' in self.buf:
            pos = self.buf.find(b'\n')
            line = self.buf[:pos]
            self.buf = self.buf[pos + 1:]
            #print('line', line)
            if b'Listening on localhost' in line:
                print('%s is ready' % self.name)
                self.state = STATE_READY
                return True
            elif b'ERROR' in line:
                pos = line.rfind(b' - ')
                err = line[pos + 3:]
                if err not in self.errs:
                    print('%s got error: %s' % (self.name, err))
                    self.errs.append(err)
        return False

    def active(self):
        if self.state in (STATE_INIT, STATE_ERROR):
            return False
        elif self.state == STATE_WAIT:
            if self.proc.poll() is None:
                return True
        elif self.state == STATE_READY:
            return True

    def kill(self):
        self.proc.kill()

    def wait_ready(self):
        done = False
        while not done and self.active():
            data = os.read(self.fd, 1000)
            if data:
                if self.process_data(data):
                    done = True
        if not self.active():
            #print('not active')
            data = os.read(self.fd, 1000)
            self.process_data(data)

    def setup_pts(self):
        if self.state == STATE_READY:
            cmd = [DUT_CONTROL, '-p', str(self.port), 'cpu_uart_pty']
            proc = self._lab.run_subprocess(*cmd)
            stdout, stderr = proc.communicate(timeout=5)
            self._pts = stdout.strip().split(b':')[-1]
            cmd = ['sudo', 'chmod', 'a+rw', self._pts]
            proc = self._lab.run_subprocess(*cmd)
            proc.communicate(timeout=1)


class Part_servo(Part):
    """Chrome OS servo board with control and UARTS for a Chromebook"""
    _lock = threading.Lock()

    def __init__(self):
        super().__init__()
        self._need_dut_power = False

    def load(self, yam):
        """Load the object from a yaml definition

        Args:
            yam (dict): Yaml definition
        """
        self._serial = yam.get('serial')
        if self._serial is None:
            self.raise_self("Missing serial")
        self._port = yam.get('port')
        if not self._port:
            self.raise_self("Missing port")
        self._board = yam.get('board')
        if not self._board:
            self.raise_self("Missing board")
        self.load_usb_port(yam)

    def __str__(self):
        """Convert the object into a string for presentation to the user"""
        return 'em100 %s' % self.name

    def raise_self(self, msg):
        """Raise an error related to this Ykusb

        Args:
            msg (str): Message to report

        Raises:
            ValueError: always
        """
        raise ValueError('%s: %s' % (str(self), msg))

    def get_detail(self, port=None):
        return '%s, port %d' % (self._serial, self._port)

    def start(self):
        comms = ServoComms(self.name, self._port, self._serial, self._board,
                           self.lab._state_dir, self.lab)
        comms.remove_logs()
        comms.start()
        comms.wait_ready()
        comms.setup_pts()
        self._comms = comms
        return work.StartResult(self, comms.state == STATE_READY)

    def stop(self):
        #self._comms.kill()
        pass

    def set_power(self, power_on: bool, port: Optional[int] = None):
        pass

    def get_reset(self):
        return 'self.servo_reset()'

    def get_poweroff(self):
        return 'self.servo_off()'

    def get_uart(self):
        return 'self.console_uart = self.servo_get_tty()'

    def get_py_class_vars(self, part_ref):
        out = {
            'servo_port': self._port,
            }
        return out

    def get_py_imports(self):
        return 'from servo import Servo'

    def get_py_base_class(self):
        return 'Servo'

    def check(self):
        """Run a check on a servo to see that it seems to work OK

        Returns:
            work.CheckResult: Result obtained from the check
        """
        with self._lock:
            result = self.lab.run_command('dut-control', '--port',
                                          str(self._port), 'cpu_uart_pty')
            if not result.return_code:
                good = True
                msg = ''
            else:
                msg = result.stderr.strip()
                good = False
            return work.CheckResult(self, good, msg)

    @classmethod
    def guess_part(cls, lab, phys):
        result = lab.get_usb_files(phys, 'idProduct', 'idVendor')
        if not result:
            return
        if result['idProduct'] == '2517' and result['idVendor'] == '0424':
            result = lab.get_usb_files(phys + '.5', 'serial')
            if not result:
                return None
            return result['serial']
        return None

    def get_code(self, prop, prop_list, partref):
        if prop == 'poweron':
            return None
        elif prop == 'poweroff':
            return None
        elif prop == 'reset':
            return 'self.servo_reset()'
        elif prop == 'setrecovery':
            return 'self.servo_recovery()'
        elif prop == 'baseclass':
            return 'Servo'
        elif prop == 'get_uart':
            return 'self.console_uart = self.servo_get_tty()'
        elif prop == 'connect_uart':
            return 'mach.open_channel("picocom", "-q", "-b", "115200", self.console_uart)'
