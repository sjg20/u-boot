# SPDX-License-Identifier: GPL-2.0+
# Copyright 2020 Google LLC
# Written by Simon Glass <sjg@chromium.org>

import re
import threading
import time

from labman.part import Part
from labman import work

class Part_em100(Part):
    """A SPI-flash emulator which can provide a firmware image to a board

    Properties:
        _serial: Serial number of the Ykusb
        _symlink: Symlink to the device
    """
    # The em100 tool seems to access all emm100 devices, not just the one with
    # the given serial number. Avoid running the tool on more than one device
    # at a time.
    _lock = threading.Lock()

    def load(self, yam):
        """Load the object from a yaml definition

        Args:
            yam (dict): Yaml definition
        """
        self.load_usb_port(yam)
        self._serial = yam.get('serial')
        if self._serial is None:
            self.raise_self("Missing serial")
        self._symlink = yam.get('symlink')
        if self._symlink is None:
            self.raise_self("Missing symlink")
        self._chip = yam.get('chip')
        if self._chip is None:
            self.raise_self("Missing chip")

    def __str__(self):
        """Convert the object into a string for presentation to the user"""
        return 'em100 %s' % self.name

    def raise_self(self, msg):
        """Raise an error related to this Ykusb

        Args:
            msg (str): Message to report

        Raises:
            ValueError: always
        """
        raise ValueError('%s: %s' % (str(self), msg))

    def get_detail(self, port=None):
        return '%s' % self._serial

    def em100(self, *in_args):
        """Perform an operation with the em100 tool

        Args:
            in_args: Arguments to pass to the tool

        Returns:
            CommandResult: Result from command

        Raises:
            ValueError: if the tool failed
        """
        with self._lock:
            # Every now an then we get:
            # libusb: error [udev_hotplug_event] ignoring udev action bind
            for _ in range(2):
                args = ['em100'] + list(in_args)
                result = self.lab.run_command(*args)
                if not result.stderr:
                    return result.stdout
        self.raise_self("Failed to run '%s': %s" %
                        (' '.join(args), result.stderr))

    def get_serial(self):
        """Get the serial number as reported by the device

        Returns:
            True if the port is on, False if off

        Raises:
            ValueError: if it did not respond
        """
        out = self.em100('-x', self._serial)
        rem = re.search(r'Serial number: ([A-Z0-9]+)', out)
        if not rem:
            self.raise_self("Unable to find status in '%s'" % out.strip())
        serial = rem.group(1)
        return serial

    def check(self):
        # Sometimes the em100 says "Could not claim interface"
        for i in range(10):
            try:
                serial = self.get_serial()
                if serial != self._serial:
                    msg = "Expected serial '%s' but got '%s'" % (self._serial,
                                                                 serial)
                    good = False
                    break
                else:
                    good = True
                    msg = ''
            except ValueError as exc:
                msg = str(exc)
                good = False
                time.sleep(.1)
        return work.CheckResult(self, good, msg)

    @classmethod
    def guess_part(cls, lab, phys):
        result = lab.get_usb_files(phys, 'idProduct', 'idVendor', 'serial')
        if not result:
            return
        if result['idVendor'] == '04b4' and result['idProduct'] == '1235':
            return '(serial number unknown)'
        return None

    def emit(self):
        emit_list = []
        emit_list.append(self.emit_udev())
        return emit_list

    def emit_udev(self):
        vals = {
            'name': str(self),
            'kernel_phys_port': self._kernel_phys_port,
            'symlink': self._symlink,
            }
        out = '''# {name}
ACTION=="add|bind" \\
, KERNELS=="{kernel_phys_port}" \\
, ATTR{{idProduct}}=="1235" \\
, ATTR{{idVendor}}=="04b4" \\
, MODE="0666" \\
, SYMLINK+="{symlink}"

'''.format(**vals)
        return work.EmitResult(self, 'udev/99-labman-em100.rules', out,
                               '# Generated by labman')

    def get_py_class_vars(self, part_ref):
        out = {
            'em100_serial': self._serial,
            'em100_chip': self._chip,
            }
        return out
