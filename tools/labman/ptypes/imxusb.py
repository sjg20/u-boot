# SPDX-License-Identifier: GPL-2.0+
# Copyright 2020 Google LLC
# Written by Simon Glass <sjg@chromium.org>

import re
import time

import collections
from labman.ptypes.usbboot import Part_usbboot
from labman import work

class Part_imxusb(Part_usbboot):
    """A Freescale iMX USB connection

    This allows downloading software to the DUT oevr USB using the boot ROM

    Properties:
        _serial: Serial number of the Ykusb
        _symlink: Symlink to the device
    """
    def __init__(self):
        super().__init__()
        self.vendor = 0x15a2
        self.product = 0x0054
        self.recovery_method = self.Method.RECOVERY_RESET

    def load(self, yam):
        """Load the object from a yaml definition

        Args:
            yam (dict): Yaml definition
        """
        super().load(yam)
        self.bct = yam.get('bct')

    def __str__(self):
        """Convert the object into a string for presentation to the user"""
        return 'imx %s' % self.name

    def raise_self(self, msg):
        """Raise an error related to this Tegra RCM connection

        Args:
            msg (str): Message to report

        Raises:
            ValueError: always
        """
        raise ValueError('%s: %s' % (str(self), msg))

    def imx(self, *in_args):
        """Perform an operation with the tegrarcm tool

        Args:
            in_args: Arguments to pass to the tool

        Returns:
            CommandResult: Result from command

        Raises:
            ValueError: if the tool failed
        """
        # This tool prints everything on stderr
        args = ['imx'] + list(in_args)
        result = self.lab.run_command(*args)
        if result.return_code:
            self.raise_self("Failed to run '%s'" % ' '.join(args))
        return result.stderr

    def get_py_class_vars(self, part_ref):
        out = super().get_py_class_vars(part_ref)
        out.update({
            #'tegra_bct': self.bct,
            })
        return out

    def emit_udev(self):
        result = super().emit_udev()

        # This device first appears with its normal VID/PID when the boot ROM is
        # in use. Then U-Boot SPL starts up with a different VID/PID, so add a
        # rule for that also.
        template = '''# {name}
ACTION=="add|bind" \\
, SUBSYSTEMS=="usb" \\
, KERNELS=="{kernel_phys_port}" \\
, ATTR{{idVendor}}=="{vendor}" \\
, ATTR{{idProduct}}=="{product}" \\
, SYMLINK+="{symlink}-spl" \\
, MODE="0666"


'''.splitlines()
        vals = {
            'name': str(self),
            'kernel_phys_port': self._kernel_phys_port,
            'symlink': self._symlink,
            'vendor': '%04x' % 0x0525,
            'product': '%04x' % 0xb4a4,
            }
        out = '\n'.join(template).format(**vals)
        return work.EmitResult(self, 'udev/99-labman-usbboot.rules',
                               result.data + out,
                               '# Generated by labman')
